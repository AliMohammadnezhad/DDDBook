
این بخش در واقع درباره‌ی چگونگی طراحی سیستم‌های نرم‌افزاری به منظور کاهش پیچیدگی آنها است. مرحله اول، شناخت دشمن است. دقیقاً "پیچیدگی" چیست؟ چگونه می‌توانیم بفهمیم که یک سیستم دچار پیچیدگی غیر ضروری شده است؟
اصلا چه عواملی باعث می‌شوند سیستم‌ها پیچیده شوند؟
در این بخش میخواهد به این سوالات در این سطح بالا ( انتزاع زیاد) پاسخ دهد؛ بخش بعدی به شما نشان خواهند داد که چگونه پیچیدگی را در سطح پایین‌تر، به اصطلاح ویژگی‌های ساختاری خاص، تشخیص دهید.

توانایی تشخیص پیچیدگی یک مهارت طراحیست. وقتی این توانایی رو داشته باشید میتونید قبل از اینکه سرمایه گذازی زیادی روی پروژتون انجام بدید این پیچیدگی هارو تشخیص بدید. تا اینکه بتونید طراحی خودتون رو اصلاح کنید و ساده ترش کنید. اما بعضی وقت ها واقعا یه سیستم پیچیدست، خوب در این حالت چی ؟ این توانایی میتونه به شما کمک کنه که اون سیستم خیلی پیچیده رو به سمت طراحی ساده تری ببرید و پروژه رو تا حد امکان هدایت کنید به سمت سادگی .

## تعریف پیچیدگی

بیاید پیچیدگی را به صورت عملی تعریف کنیم. پیچیدگی به هرچیزی که درک و اصلاح ساختار یک سیستم نرم افزاری را سخت میکند گفته میشه. پیچیدگی می‌تواند اشکال مختلفی داشته باشد. به عنوان مثال، اگر درک یک قسمت از کد سخت هست، و یا سخت میشه اصلاحش کرد، یعنی اون قسمت پیچیدگی دارد؛ و یا مثلا میخواهیم یک بخشی از سیستم را اصلاح کنیم اما زمان و انرژی زیادی میخواد و یا حتی اصلا نمیدانیم با اصلاح این قسمت کدام قسمت ها هم باید تغییر کنند؟ همچنین می‌توانید پیچیدگی را از نظر هزینه هم در نظر بگیرید. در یک سیستم پیچیده، حتی برای اعمال بهبودهای کوچک نیز نیاز به زحمت زیادی هست. در یک سیستم ساده، امکان پیاده‌سازی بهبودهای بزرگتر با کمترین زحمت و هزینه وجود دارد..

پیچیدگی اینه که یک توسعه‌دهنده در یک زمان خاص تجربه می‌کند و در هنگام تلاش برای رسیدن یک هدف خاص. این الزاماً به اندازه یا عملکرد کلی سیستم مرتبط نیست. مردم اغلب از واژه "پیچیده" برای توصیف سیستم‌های بزرگ با ویژگی‌های پیشرفته استفاده می‌کنند، اما اگر در چنین سیستمی با کلی امکانات و ویژگی های خفن باز هم بشه راحت روش کار کرد و اصلاح انجام داد، از نگاه ما سیستم دارای پیچیدگی نیست. 
البته امکان دارد که سیستم های با حجم ویژگی های کمتر پیشرفته هم دچار پیچیدگی باشند. پیچیدگی توسط فعالیت‌های رایج در سیستم تعیین می‌شود. اگر یک سیستم چند بخش داشته باشد که بسیار پیچیده هستند، اما این بخش‌ها تقریباً هرگز نیاز به تغییر ندارند، آنها تأثیر زیادی بر پیچیدگی کلی سیستم ندارند. برای توصیف این مسئله به یک روش ریاضی ساده:

 C = Zp( Cp * Tp)

پیچیدگی کل یک سیستم (C) توسط پیچیدگی هر بخش مشخص می‌شود که توسط زمانی که توسعه‌دهندگان روی آن بخش کار می‌کنند (tp) اندازه گیری میشود. ایزوله کردن و یا مخفی کردن پیچیدگی در یک جایی که هیچوقت دیده نمیشه و یا بهش سر نمیزنیم مساوی با اینه که کل پیچیدگی رو حذف کردیم.

پیچیدگی برای کسایی که کد هارو میخونن خیلی بیشتر قابل لمسه تا کسایی که اون کد هارو مینویسند. اگر یک قطعه کدی را دارید مینویسید شاید به نظر شما این ساده باشه و پیچیدگی توش درست نکرده اید، اما دیگران که میان کدهای شمارو میخونند میبینند که پیچیده است، پس در نتیجه مهم کسایی هستند که کد های شمارا میخوانند، و کد شما در این حالت پیچیدگی داره. حالا در زمان هایی که در این شرایط هستید بهتره که از دیگران بخواهید که نظرشون رو به شما بگن که چرا پیچیدگی داره، در این دیالوگ کردنه خیلی نکات و درس های جالبی میتونید یاد بگیرید. وظیفه شما به عنوان یک توسعه‌دهنده، نه تنها ایجاد کدی است که شما به راحتی با آن کار کنید، بلکه ایجاد کدی است که دیگران نیز به راحتی با آن کار کنند.

## نشانه های پیچیدگی


پیچیدگی به سه شکل عمده دیده میشه که در پاراگراف‌های زیر توضیحاتش رو میدم. هر یک از این علایم باعث سخت‌تر شدن توسعه میشه.

  
## افزایش تغییر

علامت اول پیچیدگی این است که یک تغییر به نظر ساده، نیاز به اصلاح کد در مکان‌های مختلف زیادی دارد. به عنوان مثال، یک وبسایتی داریم که چند صفحه بیشتر نیست، و هر صفحه یک بنر با یه رنگ پس زمینه داره. در بسیاری از وب‌سایت‌های اولیه، رنگ به صورت اینلاین در هر صفحه تعیین میشد. برای تغییر پس‌زمینه یک وب‌سایت مانند این، یک توسعه‌دهنده ممکن است مجبور باشد هر صفحه موجود را به صورت دستی اصلاح کند؛ این تقریباً برای یک وب‌سایت بزرگ با هزاران صفحه غیرممکن خواهد بود. خوشبختانه، وب‌سایت‌های مدرن از یک رویکرد جدید تری استفاده میکنند، جایی که رنگ بنر یک بار در یک مکان مرکزی مشخص می‌شود و تمام صفحات برای نمایش دادن رنگ پس زمینه میرند از این فایل مرکزی میخونند. با این رویکرد، رنگ بنر کل وب‌سایت با یک اصلاح ساده تغییر می‌کند. یکی از اهداف طراحی خوب کاهش اینه که اگر تصمیم به تغییرات گرفتیم کمترین زمان را برای تغییرات و ساده ترین راه رو برای تغییرات دنبال کنیم.

و یا یک مثال دیگه، سیستمی داریم که میخواهیم بهش یه قابلیت کوچیک اضافه کنیم، اما برای این قابلیت بایستی چندین فایل رو تغییر بدیم، چندین کلاس رو تغییر بدیم، کلی فانکشنالییتی رو باید عوض کنیم. و مدام باگ های جدید بوجود میاره، که مجدد بایستی برای رفع این باگ ها دوباره جاهای دیگه رو تغییر بدیم. در واقع ما ویژگی تولید نمیکنیم، داریم باگ تولید میکنیم.


## بار شناختی یا Cognitive load

علامت دوم پیچیدگی بار شناختی است که به این معنا است که توسعه‌دهنده برای انجام یک وظیفه چه مقدار باید بداند. بار شناختی به معنای این است که توسعه‌دهندگان باید بیشتر زمان خود را صرف یادگیری اطلاعات مورد نیاز کنند تا بتوانند اون تسک و یا وظیفه رو هندل کنند خوب در این حالت، خطر اشتباه به دلیل اینکه چیز مهمی را از دست داده‌اند، بیشتر است.

به عنوان مثال، فرض کنید یک متد یا یک تابع در زبان سی شارپ داریم که داره یه قسمتی از مموری رو میگیره و در نهایت یه اشاره گر به بیرون از خودش برمیگردونه، خوب یه برنامه نویسی که داره از این تابع استفاده میکنه همش باید حواسش باشه که این میزان حافظه رو آزاد کنه و یا دیسپوز کنه، خوب اگه این کار رو نکنه، باعث نشت حافظه شده، خوب بهتر نبود که همون متد وظیفه این کار رو انجام میداد؟ و دیگه بار شناختی و اینکه به برنامه نویس ها فورس کنیم که حواست به این باشه ااا، یادت نره این رو دیسپور کنی و غیره از بین میره، بنابراین بار شناختی میاد پایین و در نتیجه پیچیدگی اون کد هم میاد پایین. یا مثلا دیدیم که وقتی داریم از یه فریمورک هایی که خود توسعه دهنده ها برای تیم های خودشون مینویسند (یه زمانی اینها خوب بود اما تورو خدا الان از این کارا نکنید) به دیگر برنامه نویس ها میگن ببین داری از این استفاده میکنی حواست به این باشه، این رو اینجا کانفیگ نکردی، این رو باید اینجوری به این متد پاس بدی، این رو باید چک کنیش بعد برش گردونی و هزاران بار شناختی دیگه که همش باعث بیشتر شدن پیچیدگی میشه.

طراحان سیستم بعضی وقت ها فرض می‌کنند که پیچیدگی می‌تواند با تعداد خط کد اندازه‌گیری شود. آنها فرض می‌کنند که اگر یک پیاده‌سازی کوتاه‌تر از دیگری باشد، باید ساده‌تر باشد؛ اگر تغییری فقط چند خط کد را به خود اختصاص دهد، باید تغییری ساده باشد. با این حال، این دیدگاه هزینه‌های مرتبط با بار شناختی را نادیده می‌گیرد. من فریمورک هایی رو دیده‌ام که به برنامه‌ها این امکان را می‌دهند که با تنها چند خط کد نوشته شوند، اما بسیار سخته فهمشون که خوب این چند خط کد داره چیکار میکنه اصلا. گاهی وقت ها یک رویکردی که نیاز به تعداد بیشتری خط کد دارد در واقع ساده‌تر است، زیرا بار شناختی را کاهش می‌دهد.


## ناشناخته‌های ناشناخته Unknown unknowns:

علامت سوم پیچیدگی این است که واضح نیست کدام قسمت‌های کد باید برای انجام یک وظیفه اصلاح شود یا چه اطلاعاتی برای یک توسعه‌دهنده برای انجام موفقیت‌آمیز وظیفه لازم است. 

وب‌سایت از یک متغیر مرکزی برای تعیین رنگ پس‌زمینه بنر استفاده می‌کند، بنابراین به نظر می‌آید که تغییر آن آسان است. با این حال، چند صفحه وب از یک سایه تاریک‌تر از رنگ پس‌زمینه برای تاکید استفاده می‌کنند و آن رنگ تاریک به صورت صریح در صفحات مشخص شده است. اگر رنگ پس‌زمینه تغییر کند، آنگاه رنگ تاکید باید با رنگ جدیده تطبیق پیدا کند. متأسفانه، احتمالاً توسعه‌دهندگان این موضوع رو متوجه مخواهند شد، بنابراین ممکن است متغیر مرکزی bannerBg را بدون بروز رسانی اون رنگ تاکید تغییر دهند. حتی اگر یک توسعه‌دهنده از این مشکل هم با خبر و آگاه باشد، بازهم واضح نخواهد بود که کدام صفحات از رنگ تاکید استفاده می‌کنند، بنابراین توسعه‌دهنده ممکن است مجبور باشد هر صفحه را در وب‌سایت جستجو کند.

و یا برای یک مثال دیگه، سیستم شما داره استیت یک موجودیت رو تغییر میده، و در حالت های متفاوت این وضعیت تغییر میکنه. یه بار امکان داره در ثبت باشه، یکبار امکان داره توی یک صفحه ی دیگه بخوایم این وضعیت رو تغییر بدیم، یکبار امکان داره ادمین بخواد این کار رو انجام بده و … اگر این تغییر وضعیت رو همه جا ببریم و اونجاها کد رو بنویسیم، در زمان فعلی کاملا اوکی هست، اما در زمان تغییرات باگ هایی از جاهای دیگه برای این تغییر وضعیت میاد ، مثلا میگن که ادمین تغییر میده اعمال نمیشه، خوب میریم اونجاها رو هم درست میکنیم. اما بعضی جاها اصلا دیده نمیشن و بهشون رجوع نمیکنیم، اصلا نمیدونم که ای بابا توی فلان جای سیستم هم داره وضعیت تغییر میکنه. پس اینها علامت های ناشناخته های ناشناخته هستند که باعث بیشتر شدن سطح پیچیدگی میشن.

از سه نوع پیچیدگی، ناشناخته‌های ناشناخته بدترین هستند. یک ناشناخته ناشناخته به این معناست که چیزی وجود دارد که باید بدانید، اما هیچ راهی برای شما برای پیدا کردن آن وجود ندارد، یا بدتر اینکه آیا اصلا این مشکل وجود دارد یا خیر. 

شما تا زمانی که پس از انجام تغییرات باگ‌های جدید ظاهر نشوند، در مورد آن اطلاع پیدا نخواهید کرد. افزایش تغییرات واقعا یه مزاحم واقعی هستند، اما تا زمانی که برای شما واضح و شفاف باشد که کدام قسمت از کد باید اصلاح شود، سیستم پس از انجام آن تغییرات باز هم کار خواهد کرد. در این صورت، بار شناختی بالا هزینه تغییر را افزایش خواهد داد، اما اگر واضح باشد کدام اطلاعات باید خوانده شود، تغییر همچنان به احتمال زیاد شفاف و درست خواهد بود. در ناشناخته‌های ناشناخته، اصلا معلوم نیست که چه کاری داره انجام میده و آیا اصلا این کار میکند یا نه هم خودش مورد بحثه. تنها راه برای اطمینان اینه که هر خط کد در سیستم را بخوانید، که برای سیستم‌های خیلی بزرگ عملا غیر ممکنه.

یکی از مهم‌ترین اهداف یک طراحی خوب این است که یک سیستم واضح و شفاف باشد. این برعکس بار شناختی بالا و ناشناخته‌های ناشناخته است. در یک سیستم واضح و شفاف، یک توسعه‌دهنده به سرعت می‌تواند درک کند که چگونه کد فعلی داره کار می‌کنه و چه چیزیایی برای انجام یک تغییر نیاز هست. یک سیستم واضح و بدون پیچیدگی، سیستمی است که یک توسعه‌دهنده می‌تواند به سرعت حدس بزند که چه کاری باید انجام دهد، بدون اینکه خیلی سخت فکر کند و با اطمینان از صحت حدس خود میتواند کارش را شروع کند.

## دلایل پیچیدگی

حالا که از علائم بالا بودن سطح پیچیدگی یک سیستم نرم افزاری و دلایلی که توسعه نرم‌افزار را دشوار می‌کند آگاه هستید، مرحله بعدی اینه که بفهمیم چه چیزهایی اصلا این پیچیدگی ها را ایجاد می‌کنند، تا بتوانیم سیستم‌ها را به گونه‌ای طراحی کنیم که تا حد قابل قبولی از این دست مشکلات جلوگیری کنیم. پیچیدگی از دو عامل اصلی ناشی می‌شود: وابستگی‌ها و ابهام.

ابستگی وقتی وجود دارد که یک قطعه کد مشخص نمی‌تواند به تنهایی درک و اصلاح شود؛ یک قطعه کد به نحوی و یا به شکلی به یک کد دیگر مرتبط است و اگر قطعه کد اول تغییر کند، باید حواسمان به کد دوم باشه و یا حتی آن را هم اصلاح کنیم. یک مثال از وابستگی‌ها در پروتکل‌های شبکه رخ می‌دهد. به طور معمول کد جداگانه‌ای برای فرستنده و گیرنده برای پروتکل وجود دارد، اما هرکدام باید با پروتکل هماهنگ باشند؛ تغییر کد فرستنده تقریباً همیشه نیازمند تغییرات متناظر در گیرنده است و برعکس. امضای یک متد وابستگی‌هایی را بین پیاده سازی کننده ی آن متد و کدی که آن را فراخوانی می‌کند ایجاد می‌کند: اگر یک پارامتر جدید به یک متد اضافه شود، باید تمام فراخوانی‌های آن متد اصلاح شوند تا آن پارامتر مشخص شود.

وابستگی‌ها بخش اساسی از نرم‌افزار هستند و نمی‌توانند کاملاً حذف شوند. در واقع، ما هدفمنداً وابستگی‌ها را به عنوان یک بخش از فرآیند طراحی نرم‌افزار به طور آگاهانه معرفی می‌کنیم. هر بار که یک کلاس جدید می‌نویسید، وابستگی‌هایی در اطراف API آن کلاس ایجاد می‌شود. با این حال، یکی از اهداف طراحی نرم‌افزار این است که تعداد وابستگی‌ها را کاهش داده و وابستگی‌های باقی‌مانده را به سادگی و روشنی حداقل کنیم.