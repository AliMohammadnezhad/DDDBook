**

طبیعت پیچیدگی نرم افزار

  

![](https://lh7-us.googleusercontent.com/4rAlg_9b7CdZmycCU7wGOO4R2Dug_N464u4UKHUJh7ij4_CI4aiOwOmC5DHEGmy-C79Bzhnzx0MwJBF7Ch7xRrx77YPIRZ7l7eWa7rF8pSvgAc5xGB3mzylq-JAUNjDGemMcOTe_80eIAx-Pw5LJ2GA)

  
در این بخش می خواهیم درباره‌ی چگونگی طراحی سیستم‌های نرم‌افزاری به منظور کاهش پیچیدگی صحبت کنیم. مرحله اول، شناخت دشمن است. بله دشمن یعنی پیچیدگی. خوب حالا دقیقاً "پیچیدگی" چیست؟ چگونه می‌توانیم بفهمیم که یک سیستم دچار پیچیدگی غیر ضروری شده است؟ اصلا چه عواملی باعث می‌شوند سیستم‌ها پیچیده شوند؟

خوب حالا دقیقاً «پیچیدگی» چیست؟ چگونه می‌توانیم بفهمیم که یک سیستم دچار پیچیدگی غیر ضروری شده است؟ اصلا چه عواملی باعث می‌شوند سیستم‌ها پیچیده شوند؟

اجازه بدید به این سوالات از نگاه سطح بالاتری (انتزاع بالاتری در سطح طراحی نرم افزار) پاسخ دهیم و نه در سطح کد. و در بخش بعدی به شما نشان میدهیم که چگونه پیچیدگی را در سطح پایین‌تر یعنی در ساختار های خاص تشخیص دهید. توانایی تشخیص پیچیدگی یک مهارت طراحیست. وقتی این توانایی و مهارت طراحی رو داشته باشید میتونید قبل از اینکه سرمایه گذاری زیادی روی پروژتون انجام بدید این پیچیدگی هارو تشخیص بدید و قبل از اینکه دیر بشه بتونید طراحی خودتون رو اصلاح و ساده ترش کنید. 

اما بعضی وقت ها یه سیستم واقعا پیچیدست (از نظر بیزینسی و فرایند ها و ویژگی های خفنی که داره). خوب در این حالت چی؟ این توانایی میتونه به شما کمک کنه که اون سیستم خیلی پیچیده رو به سمت طراحی ساده تری ببرید و پروژه رو تا حد امکان به سمت سادگی هدایت کنید.

  

تعریف پیچیدگی

بیاید پیچیدگی را به صورت عملی تعریف کنیم. پیچیدگی به هرچیزی که درک و اصلاح ساختار یک سیستم نرم افزاری را سخت میکند، گفته میشه. وقتی میگیم "هر چیزی" به این نتیجه میرسیم که پیچیدگی می‌تواند اشکال مختلفی داشته باشد. به عنوان مثال، اگر درک یک قسمت از کد سخت هست، و یا سخت میشه اصلاحش کرد، یعنی اون قسمت پیچیدگی دارد؛ و یا مثلا میخواهیم یک بخشی از سیستم را اصلاح کنیم اما زمان و انرژی زیادی میخواد و یا حتی اصلا نمیدانیم با اصلاح این قسمت چه قسمت های دیگری هم باید تغییر کنند؟ همچنین می‌توانید پیچیدگی را از نظر هزینه هم در نظر بگیرید. در یک سیستم پیچیده، حتی برای اعمال بهبودهای کوچک نیاز به زحمت زیادی هست اما در یک سیستم ساده، پیاده‌سازی و بهینه سازی های بزرگ را میتوان با کمترین زحمت و هزینه انجام داد.

توسعه دهنده، پیچیدگی رو در یک زمان خاص و در زمان تلاش برای رسیدن به یک هدف خاص تجربه میکنه. ( یعنی یک توسعه دهنده پیچیدگی رو همیشه نمیبینه و توی یه زمانی خاصی بهش برمیخوره) این الزاماً به اندازه یا عملکرد کلی سیستم مرتبط نیست.

 مردم اغلب از واژه "پیچیده" برای توصیف سیستم‌های بزرگ با ویژگی‌های پیشرفته استفاده می‌کنند، اما اگر در چنین سیستمی با کلی امکانات و ویژگی های خفن باز هم بشه راحت روش کار کرد و اصلاح انجام داد، از نگاه ما سیستم دارای پیچیدگی نیست. البته امکان داره که سیستم هایی با حجم ویژگی های کمتر پیشرفته هم دچار پیچیدگی باشند. 

پیچیدگی یک سیستم توسط فعالیت‌هایی که مدام باهاش درگیر هستیم در سیستم تعیین می‌شود. اگر یک سیستم چند بخش داشته باشه که بسیار پیچیده هستند، اما این بخش‌ها تقریباً هرگز به تغییر نیاز ندارند، و هرگز بهشون سر هم نمیزنیم تا بهترشون کنیم، آنها تأثیر زیادی بر پیچیدگی کلی سیستم ندارند. یعنی پای «پیچیدگی» های نرم افزار رو قفل و زنجیر کردیم و توی یک اتاق حبس کردیم پس نگرانی بابتش نداریم. 

برای توصیف این مسئله به فرومول ریاضی ساده زیر میرسیم.

C= ∑Cp*Tp

 مجموع (پیچیدگی های هر بخش + زمان توسعه دهندگان روی آن بخش) = پیچیدگی کل سیستم 

  

پیچیدگی کل یک سیستم (C) توسط پیچیدگی هر بخش (Cp) در مدت زمانی که توسعه‌دهندگان روی آن بخش کار می‌کنند (tp) اندازه گیری میشود. ایزوله کردن و یا مخفی کردن پیچیدگی در  جایی که هیچوقت دیده نمیشه و یا بهش سر نمیزنیم مساوی با اینه که کل پیچیدگی رو حذف کردیم.

اگه بخواهیم به پیچیدگی یک سیستم از نظر دیگه ای  نگاه کنیم، پیچیدگی برای کسانی که کد ها رو میخونن خیلی بیشتر قابل لمسه تا کسایی که اون کد هارو می نویسند. اگر یک قطعه کد را دارید مینویسید، شاید به نظر شما این ساده و شفاف و سرراست باشه و پیچیدگی توش درست نکرده باشید، اما دیگران که میان کدهای شمارو میخونند میبینند که چقدر پیچیده است و چقدر درک کردنش سخته، پس در نتیجه مهم کسایی هستند که کدهای شما را میخوانند، و کد شما در این حالت پیچیدگی داره. زمانی  که در این شرایط هستید بهتره که از دیگران بخواهید که نظرشون رو به شما بگن که چرا کد شما پیچیدگی داره. در این دیالوگ کردن می تونید خیلی نکات و درس های جالبی یاد بگیرید. وظیفه شما به عنوان یک توسعه‌دهنده، نه تنها ایجاد کدی است که شما بتوانید به راحتی با آن کار کنید، بلکه ایجاد کدی است که دیگران نیز به راحتی با آن کار کنند.

  

نشانه های پیچیدگی

پیچیدگی به سه شکل عمده دیده میشه که در پاراگراف‌های زیر توضیحاتش رو میدم. هر یک از این علایم باعث سخت‌تر شدن توسعه و پیچیده شدن سیستم نرم افزاری شما میشه.

  

افزایش تغییرات

اولین علامت پیچیدگی اینه که میخوایم یک تغییر به نظر ساده ای رو انجام بدیم، اما همین تغییر ساده نیاز به اصلاح کد در فایل ها و مکان های مختلفی داره، به عنوان مثال، یک وب سایتی داریم که چند صفحه بیشتر نیست، و هر صفحه یک بنر با یه رنگ پس زمینه داره. در بسیاری از وب‌سایت‌های اولیه، رنگ به صورت اینلاین (توی Style همون المنت) در هر صفحه تعیین می شد. برای تغییر پس‌زمینه یک وب‌سایت مانند این، یک توسعه‌دهنده ممکن است مجبور باشد تمام صفحات را به صورت دستی اصلاح کند؛ این تقریباً برای یک وب‌سایت بزرگ با هزاران صفحه غیر ممکن خواهد بود. خوشبختانه، وب‌سایت‌های مدرن از یک رویکرد جدید تری استفاده می کنند، جایی که رنگ بنر یک بار در یک فایل CSS مرکزی تعیین می‌شود و تمام صفحات برای نمایش دادن رنگ پس زمینه از این فایل مرکزی استفاده میکنند. با این رویکرد، رنگ بنر کل وب‌سایت با یک تغییر ساده در اون فایل CSS تغییر می‌کند. یکی از اهداف طراحی خوب اینه که اگر تصمیم به تغییرات گرفتیم کمترین زمان و ساده ترین راه رو برای تغییرات دنبال کنیم.

حتما شما هم توی سیستم هایی که تابحال باهاشون کار کردید درگیر این تغییرات ساده و یا اضافه کردن یه ویژگی ساده به سیستم بودید، مثلا برای اضافه کردن یک ویژگی به ظاهر ساده ما باید چندین فایل رو تغییر بدهیم، چندین کلاس رو تغییر بدیم، کلی فانکشنالیتی رو باید عوض کنیم، و خوب این کار احتمالا باگ های جدید بوجود میاره، که بایستی برای رفع این باگ ها دوباره جاهای دیگه رو هم تغییر بدیم.

به قول مدیرمون مهدی: در این شرایط ما ویژگی تولید نمیکنیم، داریم باگ تولید میکنیم.

  

بار شناختی یا Cognitive load

علامت دوم پیچیدگی بار شناختی است، به این معنا که توسعه‌دهنده برای انجام یک وظیفه چه مقدار باید بداند یعنی به چقدر اطلاعات نیاز دارد؟ بار شناختی به این معناست که توسعه‌دهندگان باید بیشتر زمان خود را صرف یادگیری اطلاعات مورد نیاز کنند تا بتوانند اون تسک و یا وظیفه رو هندل کنند خوب در این حالت، خطر اشتباه به دلیل اینکه چیز مهمی را از دست داده‌اند، خیلی زیاد است. به عنوان مثال، فرض کنید یک متد یا یک تابع در زبان سی شارپ داریم که داره یه قسمتی از مموری رو میگیره و در نهایت یه اشاره گر به بیرون از خودش برمیگردونه، خوب یه برنامه نویسی که داره از این تابع استفاده میکنه همش باید حواسش باشه که این میزان حافظه رو آزاد کنه و یا دیسپوز کنه، خوب اگه این کار رو نکنه؟، باعث نشت حافظه شده. بهتر نبود که همون متد وظیفه این کار رو انجام میداد؟ و دیگه بار شناختی و اینکه به برنامه نویس ها فورس کنیم که حواست به این باشه ااا، یادت نره این رو دیسپوز کنی و غیره از بین میره، بنابراین بار شناختی میاد پایین و در نتیجه پیچیدگی اون کد هم میاد پایین.

 یک مثال دیگه فریمورک هایی است که توسعه دهنده ها برای تیم های خودشون مینویسند (یه زمانی اینها خوب بود اما تورو خدا الان از این کارا نکنید) و به دیگر برنامه نویس ها میگن ببین داری از این ویژگی استفاده میکنی حواست به این موضوع باشه، این رو اینجا کانفیگ کن ، این رو باید اینجوری به این متد پاس بدی، این رو باید چکش کنی بعد برش گردونی و هزاران بار شناختی دیگه که همش باعث بیشتر شدن پیچیدگی اون قطعه کد و بخش و در نهایت پیچیدگی کل سیستم میشه.

بعضی از طراحان سیستم فکر میکنند که میشه پیچیدگی یک سیستم را با تعداد خط کد اندازه گیری کرد، آنها فکر میکنند که اگر یک پیاده‌سازی کوتاه‌تر از دیگری باشه، ساده‌تر و درکش هم راحت تر است. و یا بدتر اینکه فکر میکنند اگر تغییر فقط چند خط کد باشه، باید تغییری ساده باشد. اما این طراحان سیستم با این دیدگاه، هزینه‌های مربوط به بار شناختی را کلا فراموش کرده اند. 

ما فریمورک هایی رو دیده‌ایم که به برنامه‌ نویس ها امکان انجام کلی کار را  تنها با چند خط کد می دهد. اما فهم این فریمورک ها بسیار سخته که خوب این چند خط کد داره چیکار میکنه اصلا؟ گاهی وقت ها تغییری که نیاز به تعداد بیشتری خط کد دارد در واقع ساده‌تر است، زیرا بار شناختی را کاهش می‌دهد.

  

ناشناخته‌های ناشناخته Unknown unknowns:

علامت سوم پیچیدگی اینه که مشخص نیست که کدام قسمت‌ از کد باید برای انجام یک تسک تغییر کند یا چه اطلاعاتی مورد نیاز یک توسعه‌دهنده برای انجام اون تسک هست. 

برگردیم به مثال وب سایت، این وب‌سایت از یک متغیر مرکزی برای تعیین رنگ پس‌زمینه بنر استفاده می‌کند، بنابراین به نظر می‌آید که تغییر آن خیلی راحت است. با این حال، چند صفحه وب برای تاکید بیشتر از یک رنگ تیره تر از رنگ معمول پس‌زمینه استفاده می‌کنند و آن رنگ تیره تر به صورت صریح در صفحات مشخص شده است. اگر رنگ پس‌زمینه تغییر کند، آنگاه رنگ تاکید باید با رنگ جدید تطبیق پیدا کند. متأسفانه، احتمالاً توسعه‌دهندگان این موضوع رو متوجه نخواهند شد، بنابراین ممکن است متغیر مرکزی bannerBg را بدون به روز رسانی اون رنگ تاکید، تغییر دهند. حتی اگر یک توسعه‌دهنده از این مشکل هم باخبر و آگاه باشد، باز هم واضح نخواهد بود که کدام صفحات از رنگ تاکید استفاده می‌کنند، بنابراین توسعه‌دهنده ممکن است مجبور باشد هر صفحه را در وب‌سایت جستجو کند.

برای یک مثال دیگه، سیستم شما داره استیت یک موجودیت رو تغییر میده و در حالت های متفاوت این وضعیت تغییر میکنه. این تغییر ممکنه در زمان ثبت باشه، یا امکان داره توی یک صفحه ی دیگه بخوایم این وضعیت رو تغییر بدیم، یکبار هم امکان داره ادمین بخواد این کار رو انجام بده و … اگر این تغییر وضعیت رو همه جا ببریم و اونجاها کد رو بنویسیم، در زمان فعلی مشکلی پیش نمیاد. اما در زمان تغییرات باگ هایی از جاهای دیگه برای این تغییر وضعیت به وجود میاد. مثلا میگن که ادمین تغییر میده ولی اعمال نمیشه. خوب میریم اونجاها رو هم درست میکنیم. اما بعضی جاها اصلا دیده نمیشن و بهشون رجوع نمیکنیم. اصلا نمیدونیم که ای بابا توی فلان جای سیستم هم داره وضعیت تغییر میکنه. 

اینها علامت های ناشناخته های ناشناخته هستند که باعث بیشتر شدن سطح پیچیدگی میشن. از سه نوع پیچیدگی، ناشناخته‌های ناشناخته بدترین هستند. یک ناشناخته ناشناخته به این معناست که چیزی وجود دارد که باید بدانید، اما هیچ راهی برای شما به منظور پیدا کردن آن چیز وجود ندارد یا بدتر اینکه آیا اصلا این مشکل وجود دارد یا خیر. 

شما تا زمانی که پس از انجام تغییرات باگ‌های جدید ظاهر نشوند، در مورد آن اطلاع پیدا نخواهید کرد. افزایش تغییرات واقعا یه مزاحم واقعی هستند، اما تا زمانی که برای شما واضح و شفاف باشد که کدام قسمت از کد باید اصلاح شود، سیستم پس از انجام آن تغییرات باز هم کار خواهد کرد. در این صورت، بار شناختی بالا هزینه تغییر را افزایش خواهد داد، اما اگر واضح باشد کدام اطلاعات باید خوانده شود، تغییر همچنان به احتمال زیاد شفاف و درست خواهد بود. 

در ناشناخته‌های ناشناخته، اصلا معلوم نیست که یک قطعه کد چه کاری داره انجام میده و این که آیا اصلا کار میکند یا نه هم خودش مورد بحثه. تنها راه برای اطمینان اینه که هر خط کد در سیستم را بخوانید. البته این کاربرای سیستم‌های خیلی بزرگ عملا غیر ممکنه.

یکی از مهم‌ترین اهداف یک طراحی خوب این است که یک سیستم واضح و شفاف باشد. این برعکس بار شناختی بالا و ناشناخته‌های ناشناخته است. در یک سیستم واضح و شفاف، یک توسعه‌دهنده به سرعت می‌تواند درک کند که چگونه کد فعلی کار می‌کنه و چه چیزهایی برای انجام یک تغییر نیاز هست. یک سیستم واضح و بدون پیچیدگی، سیستمی است که یک توسعه‌دهنده می‌تواند به سرعت حدس بزند که چه کاری باید انجام دهد، بدون اینکه خیلی سخت فکر کند و با اطمینان از صحت حدس خود میتواند کارش را شروع کند.

  

دلایل پیچیدگی

حالا که از علائم بالا بودن سطح پیچیدگی یک سیستم نرم افزاری و دلایلی که توسعه نرم‌افزار را دشوار می‌کند آگاه هستید، مرحله بعدی اینه که بفهمیم چه چیزهایی اصلا این پیچیدگی ها را ایجاد می‌کنند.، با این کارتا می بتوانیم سیستم‌ها را به گونه‌ای طراحی کنیم که تا حد قابل قبولی از این دست مشکلات جلوگیری شودکنیم. پیچیدگی از دو عامل اصلی ناشی می‌شود: وابستگی‌ها و ابهام.

وابستگی وقتی وجود دارد که یک قطعه کد مشخص نمی‌تواند به تنهایی درک و اصلاح شود؛ یعنی یک قطعه کد به نحوی و یا به شکلی به یک کد دیگر مرتبط است و اگر قطعه کد اول تغییر کند، باید حواسمان به قطعه کد دوم باشه و یا حتی آن را هم اصلاح کنیم. 

یک مثال از وابستگی‌ها در پروتکل‌های شبکه رخ می‌دهد. به طور معمول کد جداگانه‌ای برای فرستنده و گیرنده برای پروتکل وجود دارد، اما هر کدام باید با پروتکل هماهنگ باشند؛ تغییر کد فرستنده تقریباً همیشه نیازمند تغییرات متناظر در گیرنده است و برعکس. 

به عنوان مثالی دیگر امضای یک متد وابستگی‌هایی را بین پیاده سازی کننده ی آن متد و کدی که آن را فراخوانی می‌کند ایجاد می‌کند: اگر یک پارامتر جدید به یک متد اضافه شود، باید تمام فراخوانی‌های آن متد اصلاح شوند تا آن پارامتر مشخص شود.

وابستگی‌ها بخش اساسی از یک نرم‌افزار هستند و نمی‌توانند کاملاً حذف شوند. در واقع، ما وابستگی‌ها را به عنوان یک بخشی از فرآیند طراحی نرم‌افزار به طور آگاهانه معرفی می‌کنیم. هر بار که یک کلاس جدید می‌نویسید، وابستگی‌هایی در اطراف API آن کلاس ایجاد می‌شود. با این حال، یکی از اهداف طراحی نرم‌افزار این است که تعداد وابستگی‌ها را کاهش داده و وابستگی‌های باقی‌مانده را به سادگی و وضوح کامل برسانیم تا اینکه این تعداد وابستگی ها به حداقل برسند.

در نظر بگیرید مثال وب‌سایت را در نظر بگیرید. در وب‌سایت قدیمی با رنگ پس‌زمینه که به صورت جداگانه در هر صفحه مشخص می‌شد، تمام صفحات وب به یکدیگر وابسته بودند. وب‌سایت جدید این مشکل را با مشخص کردن رنگ پس‌زمینه در یک مکان مرکزی و ارائه یک API که صفحات فردی از آن استفاده می‌کنند تا رنگ را در زمان رندر شدن به دست آورند، حل کرد. 

وب‌سایت جدید وابستگی بین صفحات را حذف کرد، اما وابستگی جدیدی در اطراف API برای دریافت رنگ پس‌زمینه ایجاد کرد ولی. خوشبختانه، وابستگی جدید واضحروشن‌تر است: واضح است که هر صفحه وب فردی به رنگ bannerBg وابسته است، و یک توسعه‌دهنده می‌تواند به راحتی تمام مکان‌هایی که از این متغیر استفاده می‌شود را با جستجوی نام آن پیدا کند. علاوه بر این، کامپایلرها به مدیریت وابستگی‌های API کمک می‌کنند: اگر نام متغیر مشترک تغییر کند، خطاهای کامپایل در هر کدی که هنوز از نام قدیمی استفاده می‌کند رخ می‌دهد. وب‌سایت جدید یک وابستگی غیرواضح و سخت‌تر به مدیریت را با یک وابستگی ساده‌تر و واضح‌تر جایگزین کرد.

برگردیم به مثال وب‌سایت. در وب‌سایت قدیمی با رنگ پس‌زمینه که به صورت جداگانه در هر صفحه مشخص می‌شد، تمام صفحات وب به یکدیگر وابسته بودند. وب‌سایت جدید این مشکل را با مشخص کردن رنگ پس‌زمینه در یک مکان مرکزی و ارائه یک API که صفحات تکی از آن استفاده می‌کنند تا رنگ را در زمان رندر شدن به دست آورند، حل کرد. وب‌سایت جدید وابستگی بین صفحات را حذف کرد، اما وابستگی جدیدی در اطراف API برای دریافت رنگ پس‌زمینه ایجاد کرده است. خوشبختانه، وابستگی جدید واضح است که هر صفحه وب تکی به رنگ bannerBg وابسته است که از API می آید، و یک توسعه‌دهنده می‌تواند به راحتی تمام مکان‌هایی که از این متغیر استفاده می‌شود را با جستجوی نام آن پیدا کند. علاوه بر این، کامپایلرها به مدیریت وابستگی‌های این API کمک می‌کنند: اگر نام متغییر های این API تغییر کند، خطاهای کامپایل در هر کدی که هنوز از نام قدیمی استفاده می‌کند رخ می‌دهد. وب‌سایت جدید در واقع یک وابستگی سخت و غیر شفاف رو با یه وابستگی شفاف و ساده تر و قابل مدیریت تر جایگزین کرده است.

در حالت دوم، علت پیچیدگی، ابهام است. ابهام زمانی اتفاق می‌افتد که اطلاعات مهم واضح نیستند. یک مثال ساده نام متغیری است که به قدر کافی اطلاعات مفید را منتقل نمی‌کند (برای مثال، متغیر به نام time). یا ممکن است مستندات یک متغیر واحدهای آن را مشخص نکند.، بنابراین تنها راه برای پیدا کردن این واحدها این است که کد را دربرای مکان‌هایی که از متغیر استفاده شده است، بررسی کنید.(مثلا برای رسیدن به مقادیر enum ها حتما باید کد را باز کنیم). 

ابهام در بیشتر مواقع با وابستگی‌ها همراه است. به عنوان مثال، اگر یک وضعیت خطای جدید به یک سیستم اضافه شود، نیاز هست که این وضعیت به عنوان یک رکورد در جدولی که کل این پیام ها و وضعیت ها را نگه میدارد اضافه کنیم، اما وجود همچین جدولی برای یک برنامه نویس دیگری که میخواد کد ها رو ببینه واضح نیست و نمیتونه خیلی راحت این جدول رو پیدا کنه، و یا زمان زیادی کلی باید توی کد بگرده تا بفهمه که آهان، این خطا و این وضعیت از این جدول میاد. یه مورد دیگه ای هم که میشه در بحث مورد ابهام صحبت کرد، بحث ناهمسانی هست، به طور مثال اگر یک نام متغیر برای دو هدف مختلف استفاده شود، برای توسعه‌دهنده واضح نخواهد بود که یک متغیر خاص به کدام یک از اینها اشاره میکند.

  

به طور مثال کد زیر رو در نظر بگیرید

  

/// تعداد کاربران کل سیستم

int countOfUser = getUserCount();

  

و در جای دیگه ای از کد میبینیم که 

  

/// تعداد کاربرانی که یه پیام خاصی رو براشون فرستادیم

countOfUser = Notification.getCountOfUsers(....);

  

در بسیاری از موارد، ابهام به دلیل مستندات ناکافی ایجاد می‌شود؛ با این حال، ابهام همچنین یک مسئله طراحی  هم است. اگر یک سیستم، طراحی تمیز و واضحی داشته باشد، آنگاه نیاز به مستندات کمتری خواهد بود. نیاز به مستندات جامع و کامل و خیلی زیاد در بیشتر مواقع یک هشدار قرمز است که نشان‌ می دهددهنده این است که طراحی به درستی خوبی انجام نشده. بهترین راه برای کاهش ابهام، ساده‌سازی طراحی سیستم است. وابستگی‌ها منجر به افزایش تقویت تغییرات و بار شناختی بالا می‌شوند. ابهام ناشناخته‌ها را ایجاد می‌کند و همچنین به بار شناختی اضافه میکند. اگر بتوانیم تکنیک‌های طراحی را پیدا کنیم که وابستگی‌ها و ابهام را کم تر کنند، می‌توانیم پیچیدگی نرم‌افزار را کاهش دهیم.

  

پیچیدگی به صورت افزایشی است.هست

پیچیدگی توسط یک خطای فاحش ایجاد نمی‌شود؛ بلکه در بخش‌های کوچک جمع می‌شود. یک وابستگی یا ابهام تکی، احتمالا به تنهایی احتمالاً تاثیر قابل توجهی بر قابل نگهداری بودن یک سیستم نرم‌افزاری نخواهد داشت. پیچیدگی به وجود می‌آید چرا که صدها یا هزاران وابستگی و ابهام کوچک به مرور زمان ایجاد می‌شوند. در نهایت، تعداد زیادی از این مسائل کوچک به وجود می‌آیند که هر تغییر ممکن است توسط چندین مورد از آنها تحت تاثیر قرار گیرد.

طبیعت افزایشی پیچیدگی باعث مشکل در کنترل آن می‌شود. این خیلی آسونه که شما خودتان را قانع کنید که کمی پیچیدگی که توسط تغییر فعلی شما وارد سیستم شده است، اهمیت زیادی ندارد. اما این رویکرد رو ضرب در تعداد برنامه نویس ها بکنیم. به این معنی که اگر هر توسعه‌دهنده برای هر تغییر به این رویکرد بپردازد، پیچیدگی به سرعت افزایش پیدا می‌کند. هنگامی که پیچیدگی تجمیع شده است و افزایش پیدا کرده است، حذف آن دشوار است. آن را حذف کرد، زیرا رفع یک وابستگی یا ابهام به تنهایی اختلاف زیادی ایجاد نخواهد کرد. برای کاهش رشد پیچیدگی، باید یک فلسفه "تحمل صفر" را پیش روی خودتان بزارید. ( شاید در آینده روز های بعد در مورد این بیشتر صحبت کنیم.ردم)

  

نتیجه‌گیری

پیچیدگی از انباشت وابستگی‌ها و ابهام‌ها ناشی می‌شود. با افزایش پیچیدگی، این موضوع باعث بیشتر شدن تغییرات، بار شناختی بالا و پدیده ناشناخته می‌شود. به عبارت دیگر، برای پیاده‌سازی هر ویژگی جدید، نیاز است که مقدار زیادی ازکلی کد تغییر کند. علاوه بر این، توسعه‌دهندگان بیشترین زمان را صرف جمع‌آوری اطلاعات کافی برای انجام تغییر می‌کنند و در بدترین حالت، ممکن است حتی نتوانند تمام اطلاعات مورد نیاز را پیدا کنند. نتیجه نهایی این است که پیچیدگی، یک تغییر یک کد به ظاهر ساده شما را با خطر از دست دادن زمان و هزینه و خیلی چیزهای دیگه روبرو میکند.

  
**