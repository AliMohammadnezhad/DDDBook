**

طبیعت پیچیدگی نرم افزار

  
در این بخش میخواهیم درباره‌ی چگونگی طراحی سیستم‌های نرم‌افزاری به منظور کاهش پیچیدگی صحبت کنیم. مرحله اول، شناخت دشمن است. بله دشمن یعنی پیچیدگی. خوب حالا دقیقاً "پیچیدگی" چیست؟ چگونه می‌توانیم بفهمیم که یک سیستم دچار پیچیدگی غیر ضروری شده است؟ اصلا چه عواملی باعث می‌شوند سیستم‌ها پیچیده شوند؟

در این بخش می خواهیم به این سوالات از نگاه سطح بالاتری ( انتزاع زیاد) پاسخ دهیم. و در بخش بعدی به شما نشان میدهیم که چگونه پیچیدگی را در سطح پایین‌تر یعنی در ساختار های خاص تشخیص دهید. توانایی تشخیص پیچیدگی یک مهارت طراحیست. وقتی این توانایی و مهارت طراحی رو داشته باشید میتونید قبل از اینکه سرمایه گذاری زیادی روی پروژتون انجام بدید این پیچیدگی هارو تشخیص بدید و قبل از اینکه دیر بشه بتونید طراحی خودتون رو اصلاح و ساده ترش کنید. اما بعضی وقت ها یه سیستم واقعا پیچیدست (از نظر بیزینسی و فرایند ها و ویژگی های خفنی که داره)، خوب در این حالت چی؟ این توانایی میتونه به شما کمک کنه که اون سیستم خیلی پیچیده رو به سمت طراحی ساده تری ببرید و پروژه رو تا حد امکان به سمت سادگی هدایت کنید.

  

تعریف پیچیدگی

بیاید پیچیدگی را به صورت عملی تعریف کنیم. پیچیدگی به هرچیزی که درک و اصلاح ساختار یک سیستم نرم افزاری را سخت میکند، گفته میشه. بنابراین پیچیدگی می‌تواند اشکال مختلفی داشته باشد. به عنوان مثال، اگر درک یک قسمت از کد سخت هست، و یا سخت میشه اصلاحش کرد، یعنی اون قسمت پیچیدگی دارد؛ و یا مثلا میخواهیم یک بخشی از سیستم را اصلاح کنیم اما زمان و انرژی زیادی میخواد و یا حتی اصلا نمیدانیم با اصلاح این قسمت کدام قسمت ها هم باید تغییر کنند؟ همچنین می‌توانید پیچیدگی را از نظر هزینه هم در نظر بگیرید. در یک سیستم پیچیده، حتی برای اعمال بهبودهای کوچک نیاز به زحمت زیادی هست اما در یک سیستم ساده، پیاده‌سازی و بهینه سازی های بزرگ را میتوان با کمترین زحمت و هزینه آنها رو انجام داد.

پیچیدگی زمانی خودش رو نشون میده که یک توسعه‌دهنده در یک زمان خاص و در زمان تلاش برای رسیدن به یک هدف خاص تجربه میکنه. این الزاماً به اندازه یا عملکرد کلی سیستم مرتبط نیست. مردم اغلب از واژه "پیچیده" برای توصیف سیستم‌های بزرگ با ویژگی‌های پیشرفته استفاده می‌کنند، اما اگر در چنین سیستمی با کلی امکانات و ویژگی های خفن باز هم بشه راحت روش کار کرد و اصلاح انجام داد، از نگاه ما سیستم دارای پیچیدگی نیست. 

البته امکان دارد که سیستم های با حجم ویژگی های کمتر پیشرفته هم دچار پیچیدگی باشند. پیچیدگی توسط فعالیت‌های رایج در سیستم تعیین می‌شود. اگر یک سیستم چند بخش داشته باشد که بسیار پیچیده هستند، اما این بخش‌ها تقریباً هرگز نیاز به تغییر ندارند، آنها تأثیر زیادی بر پیچیدگی کلی سیستم ندارند. برای توصیف این مسئله به یک روش ریاضی ساده:

C= ∑Cp*Tp

پیچیدگی کل یک سیستم (C) توسط پیچیدگی هر بخش مشخص می‌شود که توسط زمانی که توسعه‌دهندگان روی آن بخش کار می‌کنند (tp) اندازه گیری میشود. ایزوله کردن و یا مخفی کردن پیچیدگی در یک جایی که هیچوقت دیده نمیشه و یا بهش سر نمیزنیم مساوی با اینه که کل پیچیدگی رو حذف کردیم.

پیچیدگی برای کسانی که کد هارو میخونن خیلی بیشتر قابل لمسه تا کسایی که اون کد هارو مینویسند. اگر یک قطعه کدی را دارید مینویسید شاید به نظر شما این ساده باشه و پیچیدگی توش درست نکرده اید، اما دیگران که میان کدهای شمارو میخونند میبینند که پیچیده است، پس در نتیجه مهم کسایی هستند که کد های شمارا میخوانند، و کد شما در این حالت پیچیدگی داره. حالا در زمان هایی که در این شرایط هستید بهتره که از دیگران بخواهید که نظرشون رو به شما بگن که چرا پیچیدگی داره، در این دیالوگ کردنه خیلی نکات و درس های جالبی میتونید یاد بگیرید. وظیفه شما به عنوان یک توسعه‌دهنده، نه تنها ایجاد کدی است که شما به راحتی با آن کار کنید، بلکه ایجاد کدی است که دیگران نیز به راحتی با آن کار کنند.

  

نشانه های پیچیدگی

پیچیدگی به سه شکل عمده دیده میشه که در پاراگراف‌های زیر توضیحاتش رو میدم. هر یک از این علایم باعث سخت‌تر شدن توسعه میشه.

  

افزایش تغییر

علامت اول پیچیدگی این است که یک تغییر به نظر ساده، نیاز به اصلاح کد در مکان‌های مختلف زیادی دارد. به عنوان مثال، یک وب سایتی داریم که چند صفحه بیشتر نیست، و هر صفحه یک بنر با یه رنگ پس زمینه داره. در بسیاری از وب‌سایت‌های اولیه، رنگ به صورت اینلاین در هر صفحه تعیین می شد. برای تغییر پس‌زمینه یک وب‌سایت مانند این، یک توسعه‌دهنده ممکن است مجبور باشد هر صفحه موجود را به صورت دستی اصلاح کند؛ این تقریباً برای یک وب‌سایت بزرگ با هزاران صفحه غیر ممکن خواهد بود. خوشبختانه، وب‌سایت‌های مدرن از یک رویکرد جدید تری استفاده می کنند، جایی که رنگ بنر یک بار در یک مکان مرکزی مشخص می‌شود و تمام صفحات برای نمایش دادن رنگ پس زمینه میرند از این فایل مرکزی میخونند. با این رویکرد، رنگ بنر کل وب‌سایت با یک اصلاح ساده تغییر می‌کند. یکی از اهداف طراحی خوب کاهش اینه که اگر تصمیم به تغییرات گرفتیم کمترین زمان را برای تغییرات و ساده ترین راه رو برای تغییرات دنبال کنیم.

و یا یک مثال دیگه، سیستمی داریم که میخواهیم بهش یه قابلیت کوچیک اضافه کنیم، اما برای این قابلیت بایستی چندین فایل رو تغییر بدیم، چندین کلاس رو تغییر بدیم، کلی فانکشنالییتی رو باید عوض کنیم. و مدام باگ های جدید بوجود میاره، که مجدد بایستی برای رفع این باگ ها دوباره جاهای دیگه رو تغییر بدیم. در واقع ما ویژگی تولید نمیکنیم، داریم باگ تولید میکنیم.

  

بار شناختی یا Cognitive load

علامت دوم پیچیدگی بار شناختی است که به این معنا است که توسعه‌دهنده برای انجام یک وظیفه چه مقدار باید بداند. بار شناختی به معنای این است که توسعه‌دهندگان باید بیشتر زمان خود را صرف یادگیری اطلاعات مورد نیاز کنند تا بتوانند اون تسک و یا وظیفه رو هندل کنند خوب در این حالت، خطر اشتباه به دلیل اینکه چیز مهمی را از دست داده‌اند، بیشتر است.

به عنوان مثال، فرض کنید یک متد یا یک تابع در زبان سی شارپ داریم که داره یه قسمتی از مموری رو میگیره و در نهایت یه اشاره گر به بیرون از خودش برمیگردونه، خوب یه برنامه نویسی که داره از این تابع استفاده میکنه همش باید حواسش باشه که این میزان حافظه رو آزاد کنه و یا دیسپوز کنه، خوب اگه این کار رو نکنه، باعث نشت حافظه شده، خوب بهتر نبود که همون متد وظیفه این کار رو انجام میداد؟ و دیگه بار شناختی و اینکه به برنامه نویس ها فورس کنیم که حواست به این باشه ااا، یادت نره این رو دیسپور کنی و غیره از بین میره، بنابراین بار شناختی میاد پایین و در نتیجه پیچیدگی اون کد هم میاد پایین. یا مثلا دیدیم که وقتی داریم از یه فریمورک هایی که خود توسعه دهنده ها برای تیم های خودشون مینویسند (یه زمانی اینها خوب بود اما تورو خدا الان از این کارا نکنید) به دیگر برنامه نویس ها میگن ببین داری از این استفاده میکنی حواست به این باشه، این رو اینجا کانفیگ نکردی، این رو باید اینجوری به این متد پاس بدی، این رو باید چک کنیش بعد برش گردونی و هزاران بار شناختی دیگه که همش باعث بیشتر شدن پیچیدگی میشه.

طراحان سیستم بعضی وقت ها فرض می‌کنند که پیچیدگی می‌تواند با تعداد خط کد اندازه‌گیری شود. آنها فرض می‌کنند که اگر یک پیاده‌سازی کوتاه‌تر از دیگری باشد، باید ساده‌تر باشد؛ اگر تغییری فقط چند خط کد را به خود اختصاص دهد، باید تغییری ساده باشد. با این حال، این دیدگاه هزینه‌های مرتبط با بار شناختی را نادیده می‌گیرد. من فریمورک هایی رو دیده‌ام که به برنامه‌ها این امکان را می‌دهند که با تنها چند خط کد نوشته شوند، اما بسیار سخته فهمشون که خوب این چند خط کد داره چیکار میکنه اصلا. گاهی وقت ها یک رویکردی که نیاز به تعداد بیشتری خط کد دارد در واقع ساده‌تر است، زیرا بار شناختی را کاهش می‌دهد.

  

ناشناخته‌های ناشناخته Unknown unknowns:

علامت سوم پیچیدگی این است که واضح نیست کدام قسمت‌های کد باید برای انجام یک وظیفه اصلاح شود یا چه اطلاعاتی برای یک توسعه‌دهنده برای انجام موفقیت‌آمیز وظیفه لازم است. 

وب‌سایت از یک متغیر مرکزی برای تعیین رنگ پس‌زمینه بنر استفاده می‌کند، بنابراین به نظر می‌آید که تغییر آن آسان است. با این حال، چند صفحه وب از یک سایه تاریک‌تر از رنگ پس‌زمینه برای تاکید استفاده می‌کنند و آن رنگ تاریک به صورت صریح در صفحات مشخص شده است. اگر رنگ پس‌زمینه تغییر کند، آنگاه رنگ تاکید باید با رنگ جدیده تطبیق پیدا کند. متأسفانه، احتمالاً توسعه‌دهندگان این موضوع رو متوجه مخواهند شد، بنابراین ممکن است متغیر مرکزی bannerBg را بدون بروز رسانی اون رنگ تاکید تغییر دهند. حتی اگر یک توسعه‌دهنده از این مشکل هم با خبر و آگاه باشد، بازهم واضح نخواهد بود که کدام صفحات از رنگ تاکید استفاده می‌کنند، بنابراین توسعه‌دهنده ممکن است مجبور باشد هر صفحه را در وب‌سایت جستجو کند.

و یا برای یک مثال دیگه، سیستم شما داره استیت یک موجودیت رو تغییر میده، و در حالت های متفاوت این وضعیت تغییر میکنه. یه بار امکان داره در ثبت باشه، یکبار امکان داره توی یک صفحه ی دیگه بخوایم این وضعیت رو تغییر بدیم، یکبار امکان داره ادمین بخواد این کار رو انجام بده و … اگر این تغییر وضعیت رو همه جا ببریم و اونجاها کد رو بنویسیم، در زمان فعلی کاملا اوکی هست، اما در زمان تغییرات باگ هایی از جاهای دیگه برای این تغییر وضعیت میاد ، مثلا میگن که ادمین تغییر میده اعمال نمیشه، خوب میریم اونجاها رو هم درست میکنیم. اما بعضی جاها اصلا دیده نمیشن و بهشون رجوع نمیکنیم، اصلا نمیدونم که ای بابا توی فلان جای سیستم هم داره وضعیت تغییر میکنه. پس اینها علامت های ناشناخته های ناشناخته هستند که باعث بیشتر شدن سطح پیچیدگی میشن. از سه نوع پیچیدگی، ناشناخته‌های ناشناخته بدترین هستند. یک ناشناخته ناشناخته به این معناست که چیزی وجود دارد که باید بدانید، اما هیچ راهی برای شما برای پیدا کردن آن وجود ندارد، یا بدتر اینکه آیا اصلا این مشکل وجود دارد یا خیر. 

شما تا زمانی که پس از انجام تغییرات باگ‌های جدید ظاهر نشوند، در مورد آن اطلاع پیدا نخواهید کرد. افزایش تغییرات واقعا یه مزاحم واقعی هستند، اما تا زمانی که برای شما واضح و شفاف باشد که کدام قسمت از کد باید اصلاح شود، سیستم پس از انجام آن تغییرات باز هم کار خواهد کرد. در این صورت، بار شناختی بالا هزینه تغییر را افزایش خواهد داد، اما اگر واضح باشد کدام اطلاعات باید خوانده شود، تغییر همچنان به احتمال زیاد شفاف و درست خواهد بود. در ناشناخته‌های ناشناخته، اصلا معلوم نیست که چه کاری داره انجام میده و آیا اصلا این کار میکند یا نه هم خودش مورد بحثه. تنها راه برای اطمینان اینه که هر خط کد در سیستم را بخوانید، که برای سیستم‌های خیلی بزرگ عملا غیر ممکنه.

یکی از مهم‌ترین اهداف یک طراحی خوب این است که یک سیستم واضح و شفاف باشد. این برعکس بار شناختی بالا و ناشناخته‌های ناشناخته است. در یک سیستم واضح و شفاف، یک توسعه‌دهنده به سرعت می‌تواند درک کند که چگونه کد فعلی داره کار می‌کنه و چه چیزیایی برای انجام یک تغییر نیاز هست. یک سیستم واضح و بدون پیچیدگی، سیستمی است که یک توسعه‌دهنده می‌تواند به سرعت حدس بزند که چه کاری باید انجام دهد، بدون اینکه خیلی سخت فکر کند و با اطمینان از صحت حدس خود میتواند کارش را شروع کند.

  

دلایل پیچیدگی

حالا که از علائم بالا بودن سطح پیچیدگی یک سیستم نرم افزاری و دلایلی که توسعه نرم‌افزار را دشوار می‌کند آگاه هستید، مرحله بعدی اینه که بفهمیم چه چیزهایی اصلا این پیچیدگی ها را ایجاد می‌کنند، تا بتوانیم سیستم‌ها را به گونه‌ای طراحی کنیم که تا حد قابل قبولی از این دست مشکلات جلوگیری کنیم. پیچیدگی از دو عامل اصلی ناشی می‌شود: وابستگی‌ها و ابهام.

وابستگی وقتی وجود دارد که یک قطعه کد مشخص نمی‌تواند به تنهایی درک و اصلاح شود؛ یک قطعه کد به نحوی و یا به شکلی به یک کد دیگر مرتبط است و اگر قطعه کد اول تغییر کند، باید حواسمان به کد دوم باشه و یا حتی آن را هم اصلاح کنیم. یک مثال از وابستگی‌ها در پروتکل‌های شبکه رخ می‌دهد. به طور معمول کد جداگانه‌ای برای فرستنده و گیرنده برای پروتکل وجود دارد، اما هر کدام باید با پروتکل هماهنگ باشند؛ تغییر کد فرستنده تقریباً همیشه نیازمند تغییرات متناظر در گیرنده است و برعکس. امضای یک متد وابستگی‌هایی را بین پیاده سازی کننده ی آن متد و کدی که آن را فراخوانی می‌کند ایجاد می‌کند: اگر یک پارامتر جدید به یک متد اضافه شود، باید تمام فراخوانی‌های آن متد اصلاح شوند تا آن پارامتر مشخص شود.

وابستگی‌ها بخش اساسی از یک نرم‌افزار هستند و نمی‌توانند کاملاً حذف شوند. در واقع، ما وابستگی‌ها را به عنوان یک بخشی از فرآیند طراحی نرم‌افزار به طور آگاهانه معرفی می‌کنیم. هر بار که یک کلاس جدید می‌نویسید، وابستگی‌هایی در اطراف API آن کلاس ایجاد می‌شود. با این حال، یکی از اهداف طراحی نرم‌افزار این است که تعداد وابستگی‌ها را کاهش داده و وابستگی‌های باقی‌مانده را به سادگی و وضوح کامل برسانیم تا اینکه این تعداد وابستگی ها به حداقل برسند.

در نظر بگیرید مثال وب‌سایت. در وب‌سایت قدیمی با رنگ پس‌زمینه که به صورت جداگانه در هر صفحه مشخص می‌شد، تمام صفحات وب به یکدیگر وابسته بودند. وب‌سایت جدید این مشکل را با مشخص کردن رنگ پس‌زمینه در یک مکان مرکزی و ارائه یک API که صفحات فردی از آن استفاده می‌کنند تا رنگ را در زمان رندر شدن به دست آورند، حل کرد. وب‌سایت جدید وابستگی بین صفحات را حذف کرد، اما وابستگی جدیدی در اطراف API برای دریافت رنگ پس‌زمینه ایجاد کرد. خوشبختانه، وابستگی جدید روشن‌تر است: واضح است که هر صفحه وب فردی به رنگ bannerBg وابسته است، و یک توسعه‌دهنده می‌تواند به راحتی تمام مکان‌هایی که از این متغیر استفاده می‌شود را با جستجوی نام آن پیدا کند. علاوه بر این، کامپایلرها به مدیریت وابستگی‌های API کمک می‌کنند: اگر نام متغیر مشترک تغییر کند، خطاهای کامپایل در هر کدی که هنوز از نام قدیمی استفاده می‌کند رخ می‌دهد. وب‌سایت جدید یک وابستگی غیرواضح و سخت‌تر به مدیریت را با یک وابستگی ساده‌تر و واضح‌تر جایگزین کرد.

برگردیم به مثال وب‌سایت. در وب‌سایت قدیمی با رنگ پس‌زمینه که به صورت جداگانه در هر صفحه مشخص می‌شد، تمام صفحات وب به یکدیگر وابسته بودند. وب‌سایت جدید این مشکل را با مشخص کردن رنگ پس‌زمینه در یک مکان مرکزی و ارائه یک API که صفحات تکی از آن استفاده می‌کنند تا رنگ را در زمان رندر شدن به دست آورند، حل کرد. وب‌سایت جدید وابستگی بین صفحات را حذف کرد، اما وابستگی جدیدی در اطراف API برای دریافت رنگ پس‌زمینه ایجاد کرده است. خوشبختانه، وابستگی جدید واضح است که هر صفحه وب تکی به رنگ bannerBg وابسته است که از API می آید، و یک توسعه‌دهنده می‌تواند به راحتی تمام مکان‌هایی که از این متغیر استفاده می‌شود را با جستجوی نام آن پیدا کند. علاوه بر این، کامپایلرها به مدیریت وابستگی‌های این API کمک می‌کنند: اگر نام متغییر های این API تغییر کند، خطاهای کامپایل در هر کدی که هنوز از نام قدیمی استفاده می‌کند رخ می‌دهد. وب‌سایت جدید در واقع یک وابستگی سخت و غیر شفاف رو با یه وابستگی شفاف و ساده تر و قابل مدیریت تر جایگزین کرده است.

در حالت دوم، علت پیچیدگی ابهام است. ابهام زمانی اتفاق می‌افتد که اطلاعات مهم واضح نیستند. یک مثال ساده نام متغیری است که به قدر کافی اطلاعات مفید را منتقل نمی‌کند (برای مثال، متغیر به نام time). یا ممکن است مستندات یک متغیر واحدهای آن را مشخص نکند، بنابراین تنها راه برای پیدا کردن این است که کد را برای مکان‌هایی که از متغیر استفاده شده است، بررسی کنید.(مثلا برای رسیدن به مقادیر enum ها حتما باید کد را باز کنیم). ابهام در بیشتر مواقع با وابستگی‌ها همراه است. به عنوان مثال، اگر یک وضعیت خطای جدید به یک سیستم اضافه شود، نیاز هست که این وضعیت به عنوان یک رکورد در جدولی که کل این پیام ها و وضعیت ها را نگه میدارد اضافه کنیم، اما وجود همچین جدولی برای یک برنامه نویس دیگری که میخواد کد هارو ببینه واضح نیست و نمیتونه خیلی راحت این جدول رو پیدا کنه، و یا کلی باید توی کد بگرده تا بفهمه که آهان، این خطا و این وضعیت از این جدول میاد. یه مورد دیگه ای هم که میشه در مورد ابهام صحبت کرد، بحث ناهمسانی هست، به طور مثال اگر یک نام متغیر برای دو هدف مختلف استفاده شود، برای توسعه‌دهنده واضح نخواهد بود که یک متغیر خاص به کدام یک از اینها اشاره میکند.

  

به طور مثال کد زیر رو در نظر بگیرید

  

/// تعداد کاربران کل سیستم

int countOfUser = getUserCount();

  

و در جای دیگه ای از کد میبینیم که 

  

/// تعداد کاربرانی که یه پیام خاصی رو براشون فرستادیم

countOfUser = Notification.getCountOfUsers(....);

  

در بسیاری از موارد، ابهام به دلیل مستندات ناکافی ایجاد می‌شود؛ با این حال، ابهام همچنین یک مسئله طراحی  هم است. اگر یک سیستم طراحی تمیز و واضحی داشته باشد، آنگاه نیاز به مستندات کمتری خواهد بود. نیاز به مستندات جامع و کامل و خیلی زیاد در بیشتر مواقع یک هشدار قرمز است که نشان‌دهنده این است که طراحی به خوبی انجام نشده. بهترین راه برای کاهش ابهام، ساده‌سازی طراحی سیستم است. وابستگی‌ها منجر به تقویت تغییرات و بار شناختی بالا می‌شوند. ابهام ناشناخته‌ها را ایجاد می‌کند و همچنین به بار شناختی اضافه میکند. اگر بتوانیم تکنیک‌های طراحی را پیدا کنیم که وابستگی‌ها و ابهام را کم تر کنند، می‌توانیم پیچیدگی نرم‌افزار را کاهش دهیم.

  

پیچیدگی به صورت افزایشی هست

پیچیدگی توسط یک خطای فاحش ایجاد نمی‌شود؛ بلکه در بخش‌های کوچک جمع می‌شود. یک وابستگی یا ابهام تکی به تنهایی احتمالاً تاثیر قابل توجهی بر قابل نگهداری بودن یک سیستم نرم‌افزاری نخواهد داشت. پیچیدگی به وجود می‌آید چرا که صدها یا هزاران وابستگی و ابهام کوچک به مرور زمان ایجاد می‌شوند. در نهایت، تعداد زیادی از این مسائل کوچک به وجود می‌آیند که هر تغییر ممکن است توسط چندین مورد از آنها تحت تاثیر قرار گیرد.

طبیعت افزایشی پیچیدگی باعث مشکل در کنترل آن می‌شود. این خیلی آسونه که شما خودتان را قانع کنید که کمی پیچیدگی که توسط تغییر فعلی شما وارد سیستم شده است، اهمیت زیادی ندارد. اما این رویکرد رو ضرب در تعداد برنامه نویس ها بکنیم به این معنی که اگر هر توسعه‌دهنده برای هر تغییر به این رویکرد بپردازد، پیچیدگی به سرعت افزایش پیدا می‌کند. هنگامی که پیچیدگی تجمیع شده است و افزایش پیدا کرده است، دشوار است آن را حذف کرد، زیرا رفع یک وابستگی یا ابهام به تنهایی اختلاف زیادی ایجاد نخواهد کرد. برای کاهش رشد پیچیدگی، باید یک فلسفه "تحمل صفر" را پیش روی خودتان بزارید. ( شاید در روز های بعد در مورد این بیشتر صحبت کردم)

  

نتیجه‌گیری

پیچیدگی از انباشت وابستگی‌ها و ابهام‌ها ناشی می‌شود. با افزایش پیچیدگی، این موضوع باعث بیشتر شدن تغییرات، بار شناختی بالا و پدیده ناشناخته می‌شود. به عبارت دیگر، برای پیاده‌سازی هر ویژگی جدید، نیاز است که کلی کد تغییر کند. علاوه بر این، توسعه‌دهندگان بیشترین زمان را صرف جمع‌آوری اطلاعات کافی برای انجام تغییر می‌کنند و در بدترین حالت، ممکن است حتی نتوانند تمام اطلاعات مورد نیاز را پیدا کنند. نتیجه نهایی این است که پیچیدگی، تغییر یک کد به ظاهر ساده شما را با خطر از دست دادن زمان و هزینه و خیلی چیزهای دیگه روبرو میکند

  
**