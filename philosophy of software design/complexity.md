
این بخش در واقع درباره‌ی چگونگی طراحی سیستم‌های نرم‌افزاری به منظور کاهش پیچیدگی آنها است. مرحله اول، شناخت دشمن است. دقیقاً "پیچیدگی" چیست؟ چگونه می‌توانیم بفهمیم که یک سیستم دچار پیچیدگی غیر ضروری شده است؟
اصلا چه عواملی باعث می‌شوند سیستم‌ها پیچیده شوند؟
در این بخش میخواهد به این سوالات در این سطح بالا ( انتزاع زیاد) پاسخ دهد؛ بخش بعدی به شما نشان خواهند داد که چگونه پیچیدگی را در سطح پایین‌تر، به اصطلاح ویژگی‌های ساختاری خاص، تشخیص دهید.

توانایی تشخیص پیچیدگی یک مهارت طراحیست. وقتی این توانایی رو داشته باشید میتونید قبل از اینکه سرمایه گذازی زیادی روی پروژتون انجام بدید این پیچیدگی هارو تشخیص بدید. تا اینکه بتونید طراحی خودتون رو اصلاح کنید و ساده ترش کنید. اما بعضی وقت ها واقعا یه سیستم پیچیدست، خوب در این حالت چی ؟ این توانایی میتونه به شما کمک کنه که اون سیستم خیلی پیچیده رو به سمت طراحی ساده تری ببرید و پروژه رو تا حد امکان هدایت کنید به سمت سادگی .

## تعریف پیچیدگی

بیاید پیچیدگی را به صورت عملی تعریف کنیم. پیچیدگی به هرچیزی که درک و اصلاح ساختار یک سیستم نرم افزاری را سخت میکند گفته میشه. پیچیدگی می‌تواند اشکال مختلفی داشته باشد. به عنوان مثال، اگر درک یک قسمت از کد سخت هست، و یا سخت میشه اصلاحش کرد، یعنی اون قسمت پیچیدگی دارد؛ و یا مثلا میخواهیم یک بخشی از سیستم را اصلاح کنیم اما زمان و انرژی زیادی میخواد و یا حتی اصلا نمیدانیم با اصلاح این قسمت کدام قسمت ها هم باید تغییر کنند؟ همچنین می‌توانید پیچیدگی را از نظر هزینه هم در نظر بگیرید. در یک سیستم پیچیده، حتی برای اعمال بهبودهای کوچک نیز نیاز به زحمت زیادی هست. در یک سیستم ساده، امکان پیاده‌سازی بهبودهای بزرگتر با کمترین زحمت و هزینه وجود دارد..

پیچیدگی اینه که یک توسعه‌دهنده در یک زمان خاص تجربه می‌کند و در هنگام تلاش برای رسیدن یک هدف خاص. این الزاماً به اندازه یا عملکرد کلی سیستم مرتبط نیست. مردم اغلب از واژه "پیچیده" برای توصیف سیستم‌های بزرگ با ویژگی‌های پیشرفته استفاده می‌کنند، اما اگر در چنین سیستمی با کلی امکانات و ویژگی های خفن باز هم بشه راحت روش کار کرد و اصلاح انجام داد، از نگاه ما سیستم دارای پیچیدگی نیست. 
البته امکان دارد که سیستم های با حجم ویژگی های کمتر پیشرفته هم دچار پیچیدگی باشند. پیچیدگی توسط فعالیت‌های رایج در سیستم تعیین می‌شود. اگر یک سیستم چند بخش داشته باشد که بسیار پیچیده هستند، اما این بخش‌ها تقریباً هرگز نیاز به تغییر ندارند، آنها تأثیر زیادی بر پیچیدگی کلی سیستم ندارند. برای توصیف این مسئله به یک روش ریاضی ساده:

 C = Zp( Cp * Tp)

پیچیدگی کل یک سیستم (C) توسط پیچیدگی هر بخش مشخص می‌شود که توسط زمانی که توسعه‌دهندگان روی آن بخش کار می‌کنند (tp) اندازه گیری میشود. ایزوله کردن و یا مخفی کردن پیچیدگی در یک جایی که هیچوقت دیده نمیشه و یا بهش سر نمیزنیم مساوی با اینه که کل پیچیدگی رو حذف کردیم.

پیچیدگی برای کسایی که کد هارو میخونن خیلی بیشتر قابل لمسه تا کسایی که اون کد هارو مینویسند. اگر یک قطعه کدی را دارید مینویسید شاید به نظر شما این ساده باشه و پیچیدگی توش درست نکرده اید، اما دیگران که میان کدهای شمارو میخونند میبینند که پیچیده است، پس در نتیجه مهم کسایی هستند که کد های شمارا میخوانند، و کد شما در این حالت پیچیدگی داره. حالا در زمان هایی که در این شرایط هستید بهتره که از دیگران بخواهید که نظرشون رو به شما بگن که چرا پیچیدگی داره، در این دیالوگ کردنه خیلی نکات و درس های جالبی میتونید یاد بگیرید. وظیفه شما به عنوان یک توسعه‌دهنده، نه تنها ایجاد کدی است که شما به راحتی با آن کار کنید، بلکه ایجاد کدی است که دیگران نیز به راحتی با آن کار کنند.

## نشانه های پیچیدگی

**

پیچیدگی به سه شکل عمده دیده میشه که در پاراگراف‌های زیر توضیحاتش رو میدم. هر یک از این علایم باعث سخت‌تر شدن توسعه میشه.

  
افزایش تغییر: علامت اول پیچیدگی این است که یک تغییر به نظر ساده، نیاز به اصلاح کد در مکان‌های مختلف زیادی دارد. به عنوان مثال، یک وبسایتی داریم که چند صفحه بیشتر نیست، و هر صفحه یک بنر با یه رنگ پس زمینه داره. در بسیاری از وب‌سایت‌های اولیه، رنگ به صورت اینلاین در هر صفحه تعیین میشد. برای تغییر پس‌زمینه یک وب‌سایت مانند این، یک توسعه‌دهنده ممکن است مجبور باشد هر صفحه موجود را به صورت دستی اصلاح کند؛ این تقریباً برای یک وب‌سایت بزرگ با هزاران صفحه غیرممکن خواهد بود. خوشبختانه، وب‌سایت‌های مدرن از یک رویکرد جدید تری استفاده میکنند، جایی که رنگ بنر یک بار در یک مکان مرکزی مشخص می‌شود و تمام صفحات برای نمایش دادن رنگ پس زمینه میرند از این فایل مرکزی میخونند. با این رویکرد، رنگ بنر کل وب‌سایت با یک اصلاح ساده تغییر می‌کند. یکی از اهداف طراحی خوب کاهش اینه که اگر تصمیم به تغییرات گرفتیم کمترین زمان را برای تغییرات و ساده ترین راه رو برای تغییرات دنبال کنیم.

و یا یک مثال دیگه، سیستمی داریم که میخواهیم بهش یه قابلیت کوچیک اضافه کنیم، اما برای این قابلیت بایستی چندین فایل رو تغییر بدیم، چندین کلاس رو تغییر بدیم، کلی فانکشنالییتی رو باید عوض کنیم. و مدام باگ های جدید بوجود میاره، که مجدد بایستی برای رفع این باگ ها دوباره جاهای دیگه رو تغییر بدیم. در واقع ما ویژگی تولید نمیکنیم، داریم باگ تولید میکنیم.

**